/**
 * Function To Array Replacements
 * The obfuscated script dynamically generates an array which is referenced throughout the script.
 */
import utils from '../utils/index.js';
import {Sandbox} from '../utils/sandbox.js';
import {evalInVm} from '../utils/evalInVm.js';
const {createOrderedSrc, getDeclarationWithContext} = utils;

/**
 * Identifies VariableDeclarator nodes with function calls that generate arrays.
 * Matches variables assigned function call results where all references are member expressions
 * (indicating array-like usage).
 * @param {Arborist} arb - The Arborist instance
 * @param {Function} [candidateFilter] - Optional filter for candidates
 * @return {ASTNode[]} Array of VariableDeclarator nodes ready for array resolution
 */
export function resolveFunctionToArrayMatch(arb, candidateFilter = () => true) {
	const matches = [];
	const relevantNodes = arb.ast[0].typeMap.VariableDeclarator;
	
	for (let i = 0; i < relevantNodes.length; i++) {
		const n = relevantNodes[i];
		
		// Must be a variable assigned a function call result
		if (n.init?.type !== 'CallExpression') continue;
		
		// All references must be member expressions that are NOT used as function callees
		// Empty references array is allowed
		if (n.id.references?.some(r => {
			return r.parentNode.type !== 'MemberExpression' || 
			       (r.parentNode.parentNode?.type === 'CallExpression' && 
			        r.parentNode.parentNode.callee === r.parentNode);
		})) continue;
		
		if (candidateFilter(n)) {
			matches.push(n);
		}
	}
	return matches;
}

/**
 * Transforms matched VariableDeclarator nodes by evaluating their function calls
 * and replacing them with the resolved array literals. Handles context dependencies
 * to ensure the generating function can be properly executed.
 * @param {Arborist} arb - The Arborist instance
 * @param {ASTNode[]} matches - Array of VariableDeclarator nodes to transform
 * @return {Arborist} The updated Arborist instance
 */
export function resolveFunctionToArrayTransform(arb, matches) {
	if (!matches.length) return arb;
	
	const sharedSb = new Sandbox();
	
	for (let i = 0; i < matches.length; i++) {
		const n = matches[i];
		
		// Determine the target node that contains the function definition
		const targetNode = n.init.callee?.declNode?.parentNode || n.init;
		
		// Build evaluation context - include function definition if it's separate
		let src = '';
		if (![n.init, n.init?.parentNode].includes(targetNode)) {
			// Function is defined elsewhere, include its context
			src += createOrderedSrc(getDeclarationWithContext(targetNode));
		}
		
		// Add the function call to evaluate
		src += `\n;${createOrderedSrc([n.init])}\n;`;
		
		const replacementNode = evalInVm(src, sharedSb);
		if (replacementNode !== evalInVm.BAD_VALUE) {
			arb.markNode(n.init, replacementNode);
		}
	}
	return arb;
}

/**
 * Resolves function calls that generate arrays by evaluating them and replacing
 * with the actual array literals. This handles obfuscation patterns where arrays
 * are dynamically generated by functions and then accessed via member expressions.
 * @param {Arborist} arb - The Arborist instance
 * @param {Function} [candidateFilter] - Optional filter function for candidates
 * @return {Arborist} The updated Arborist instance
 */
export default function resolveFunctionToArray(arb, candidateFilter = () => true) {
	const matches = resolveFunctionToArrayMatch(arb, candidateFilter);
	return resolveFunctionToArrayTransform(arb, matches);
}